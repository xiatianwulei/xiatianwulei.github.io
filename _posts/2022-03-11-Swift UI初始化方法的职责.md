---
layout:     post
title:      Swift UI初始化方法的职责
subtitle:   
date:       2022-03-11
author:     夏天无泪
header-img: img/post-bg-digital-native.jpg?raw=true
catalog: true
tags:
    - Swift
---

# Swift UI 初始化方法的正确职责

在 iOS 开发中，正确理解和使用生命周期方法是非常重要的，尤其是当使用 NIB/XIB 文件或进行 UI 配置时。下面是关于常用生命周期方法的职责和最佳实践：

## 一、`awakeFromNib()` 的正确职责

`awakeFromNib()` 方法会在 NIB/XIB 文件加载并初始化所有视图后立即调用。此时，虽然视图已经实例化，但有以下几点需要注意：

- **视图尚未布局**：此时 `frame` 和 `bounds` 可能还不准确。
- **视图层级可能不完整**：子视图可能尚未完全加入父视图。
- **主 Actor 上下文可能未完全建立**：在 Swift 6 中，主线程的严格检查可能导致访问 UI 属性时出现问题。

**适合放在 `awakeFromNib()` 中的操作：**

1. **非 UI 的初始化**：如设置数据模型、注册通知。
2. **一次性配置**：如设置代理、添加 KVO 观察。
3. **弱引用存储**：如保存对 `ViewModel` 的引用。

**示例：**

```swift
override func awakeFromNib() {
    super.awakeFromNib()
    
    // 注册通知中心
    NotificationCenter.default.addObserver(
        self,
        selector: #selector(handleNotification),
        name: .someNotification,
        object: nil
    )
    
    // 设置代理
    someView.delegate = self
    
    // 非 UI 配置
    isUserInteractionEnabled = true
}
```

## 二、`layoutSubviews()` 的职责

`layoutSubviews()` 方法会在每次视图布局时调用（包括首次显示前）。

1. 获取准确的布局数据
此时 bounds、frame、center 等属性已确定，可安全获取视图的实际尺寸和位置，例如：
```
override func layoutSubviews() {
    super.layoutSubviews()
    // 此时获取的尺寸是准确的
    let buttonWidth = changYongBtn.bounds.width
    let collectionViewHeight = timeCollectionView.frame.height
}

```

2. 基于布局数据的动态调整
如果某些 UI 配置依赖视图的实际尺寸（如根据宽度调整字体大小、根据高度裁剪内容），适合在这里处理：
```
override func layoutSubviews() {
    super.layoutSubviews()
    // 根据按钮宽度动态调整字体
    changYongBtn.titleLabel?.font = UIFont.systemFont(ofSize: changYongBtn.bounds.width > 100 ? 16 : 14)
}

```
3. 非频繁的约束微调
如果必须根据布局结果修改约束（如修正子视图位置偏差），可以在这里做，但必须加判断避免重复执行：
```
override func layoutSubviews() {
    super.layoutSubviews()
    // 仅在约束值不符合预期时修改
    if timeCollectionViewH.constant != timeCollectionView.bounds.height {
        timeCollectionViewH.constant = timeCollectionView.bounds.height
    }
}
```

4. layoutSubviews() 不适合做的事（避坑点）
* 1 频繁修改约束或赋值
该方法会被频繁调用（如滚动、旋转屏幕时），如果每次都执行 timeCollectionViewH.constant = 106 这类固定值赋值，属于无效操作，浪费 CPU 资源。
* 2 耗时操作
避免在其中执行富文本处理、图片解码、数据计算等耗时任务，会导致布局阻塞，引发卡顿。
* 3 无判断的重复创建对象
如下代码每次调用都会创建新的 CAShapeLayer，严重影响性能：
 
    ```
    // 错误示例：频繁创建对象
    override func layoutSubviews() {
    super.layoutSubviews()
    let maskLayer = CAShapeLayer() // 每次调用都创建新对象
    maskLayer.path = ...
    view.layer.mask = maskLayer
    }
    ```
总结: 关键原则：“读取为主，修改为辅，避免重复”
读取优先：layoutSubviews() 最适合做 “读取布局数据” 的操作（这是它的设计初衷）。
修改谨慎：如需修改约束或赋值，必须满足两个条件：
修改逻辑依赖当前布局结果（如根据实际宽度调整约束）；
加判断条件避免重复执行（用 if 检查是否需要修改）。
禁止耗时操作：任何可能阻塞主线程的任务（如计算、IO 操作）都不应放在这里。



## 三、其他可替代的生命周期方法

### 1. `didMoveToSuperview()`

在视图被添加到父视图后调用，只会执行一次。适用于视图首次添加时的初始化操作。

**示例：**

```swift
override func didMoveToSuperview() {
    super.didMoveToSuperview()
    if superview != nil {
        // 仅在视图首次添加到父视图时执行
        registerStatusImageView.isHidden = true
    }
}
```
### 2. `willMove(toSuperview:)`
在视图即将被添加到父视图时调用。适用于需要预配置的场景。

**示例：**
```
override func willMove(toSuperview newSuperview: UIView?) {
    super.willMove(toSuperview: newSuperview)
    if newSuperview != nil {
        // 即将被添加到父视图时执行
        registerStatusImageView.isHidden = true
    }
}
```
## 四、Swift 6 下的最佳实践

在 Swift 6 中，`@MainActor` 和严格的并发检查要求我们更加小心地处理 UI 更新。

### 1. 避免在 `awakeFromNib()` 中直接操作 UI

在 `awakeFromNib()` 中，不要直接操作 UI 属性。可以使用 `DispatchQueue.main.async` 或 `Task { @MainActor in ... }` 来确保 UI 更新在主线程中执行。

### 2. 优先在 `layoutSubviews()` 根据当前布局状态调整 UI

`layoutSubviews()` 是在视图布局完成时调用的，此时可以安全地进行 UI 更新。避免在该方法中进行过多的初始化逻辑，以减少不必要的调用。

### 3. 使用 `@MainActor` 标记整个类

标记类为 `@MainActor`，可以确保所有方法都在主线程上执行，避免并发访问 UI 时的线程安全问题。

**示例：封装 UI 更新逻辑**

```swift
private func updateUI() {
    Task { @MainActor in
        registerStatusImageView.isHidden = true
        // 其他 UI 更新...
    }
}
```
## 五、总结

| 方法                        | 适合场景                      | Swift 6 注意事项                      |
|----------------------------|-------------------------------|----------------------------------------|
| `awakeFromNib()`            | 非 UI 初始化、设置代理        | 避免直接访问 UI 属性                   |
| `layoutSubviews()`          | UI 初始化、动态布局          | 安全访问 UI，但可能被多次调用         |
| `didMoveToSuperview()`      | 一次性 UI 初始化             | 视图添加到父视图后执行                 |
| `willMove(toSuperview:)`    | 视图即将添加到父视图时       | 可用于预配置 UI                       |


## 六、补充

### 修改约束 / 布局的逻辑 应该放在 `layoutSubviews()` 中（或普通方法中，由 `layoutSubviews()` 调用）

`layoutIfNeeded()` 仅仅是触发立即执行布局的 “开关”，本身不应该包含任何布局修改逻辑。

### 为什么不能在 `layoutIfNeeded()` 里修改约束？

1. **职责混淆**：`layoutIfNeeded()` 的设计目的是 “执行布局”，而不是 “定义布局规则”。它的作用是触发系统去计算和应用布局，而不是在里面编写 “如何布局” 的逻辑。
2. **可能导致循环**：如果在 `layoutIfNeeded()` 中修改约束，会再次标记布局为 “待更新”，可能引发重复调用，甚至死循环。
3. **不符合系统设计**：系统的布局流程是：`setNeedsLayout()`（标记需要更新）→ `layoutIfNeeded()`（触发执行）→ 自动调用 `layoutSubviews()`（执行具体布局）。修改约束的逻辑属于 “执行具体布局” 的部分，理应放在 `layoutSubviews()` 中。

### 正确的代码组织方式

假设你需要根据数据模型修改拖拽相关的约束，应该这样做：

```swift
// 1. 重写 layoutSubviews()，在这里编写布局逻辑
override func layoutSubviews() {
    super.layoutSubviews() // 必须先调用父类方法
    
    // 根据数据模型修改约束（这是正确的位置）
    updateConstraintsWithModel()
}

// 2. 单独的方法处理约束修改
private func updateConstraintsWithModel() {
    // 例如：根据 model 的拖拽位置更新约束
    dragConstraint.constant = model.dragOffset
    // 其他布局调整...
}

// 3. 需要立即更新布局时，调用 layoutIfNeeded() 触发
func someAction() {
    // 当数据模型变化后，需要立即看到布局效果
    model.dragOffset = 100
    layoutIfNeeded() // 仅触发，不包含布局逻辑
}

// 4.点击事件处理方法
@IBAction func buttonTapped(_ sender: UIButton) {
    // 1. 直接修改约束（在点击事件中）
    if timeCollectionViewH.constant == 106 {
        timeCollectionViewH.constant = 200 // 点击后调整高度
    } else {
        timeCollectionViewH.constant = 106 // 恢复原高度
    }
    
    // 2. 可选：如果需要动画过渡，用 UIView.animate 包裹 layoutIfNeeded()
    UIView.animate(withDuration: 0.3) {
        self.layoutIfNeeded() // 触发布局更新，带动画效果
    }
}
```

#### 写个小demo 记录下

##### cell
```
import UIKit

class DynamicHeightCell: UITableViewCell {
    // 从XIB拖线的Label
    @IBOutlet weak var contentLabel: UILabel!
    // 从XIB拖线的Label高度约束
    @IBOutlet weak var labelHeightConstraint: NSLayoutConstraint!
    // 切换按钮
    @IBOutlet weak var toggleButton: UIButton!
    
    // 记录展开状态
    var isExpanded: Bool = false {
        didSet {
            // 状态改变时更新UI
            updateLabelHeight()
        }
    }
    
    // 点击按钮的回调闭包
    var onToggle: (() -> Void)?
    
    override func awakeFromNib() {
        super.awakeFromNib()
        // 初始化设置
        updateLabelHeight()
    }
    
    // 在layoutSubviews中确保布局正确
    override func layoutSubviews() {
        super.layoutSubviews()
        // 可以在这里根据需要调整布局
    }
    
    // 更新Label高度约束
    private func updateLabelHeight() {
        // 根据状态设置不同的高度
        labelHeightConstraint.constant = isExpanded ? 100 : 20
        // 强制刷新当前Cell的布局
        layoutIfNeeded()
    }
    
    // 按钮点击事件
    @IBAction func toggleButtonTapped(_ sender: UIButton) {
        onToggle?()
    }
    
    // 配置Cell内容
    func configure(with text: String) {
        contentLabel.text = text
        // 根据内容多少可能需要设置换行模式
        contentLabel.numberOfLines = isExpanded ? 0 : 1
    }
} 

```
    
    
##### vc
    
```
import UIKit

class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {
    
    @IBOutlet weak var tableView: UITableView!
    
    // 存储每个cell的展开状态
    var expandedStates: [Bool] = Array(repeating: false, count: 10)
    // 测试数据
    let cellTexts: [String] = {
        var texts = [String]()
        for i in 0..<10 {
            texts.append("这是第\(i+1)个单元格的内容，点击按钮可以展开更多内容查看完整信息。")
        }
        return texts
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 注册XIB文件
        tableView.register(UINib(nibName: "DynamicHeightCell", bundle: nil), forCellReuseIdentifier: "DynamicHeightCell")
        
        // 设置自动计算高度
        tableView.rowHeight = UITableView.automaticDimension
        tableView.estimatedRowHeight = 60
    }
    
    // MARK: - UITableViewDataSource
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return cellTexts.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "DynamicHeightCell", for: indexPath) as! DynamicHeightCell
        
        // 配置Cell
        cell.configure(with: cellTexts[indexPath.row])
        cell.isExpanded = expandedStates[indexPath.row]
        cell.toggleButton.setTitle(cell.isExpanded ? "收起" : "展开", for: .normal)
        
        // 设置按钮点击回调
        cell.onToggle = { [weak self] in
            guard let self = self else { return }
            
            // 切换状态
            self.expandedStates[indexPath.row].toggle()
            
            // 更新按钮文字
            cell.toggleButton.setTitle(self.expandedStates[indexPath.row] ? "收起" : "展开", for: .normal)
            
            // 通知TableView更新高度
            tableView.beginUpdates()
            tableView.endUpdates()
        }
        
        return cell
    }
}
```