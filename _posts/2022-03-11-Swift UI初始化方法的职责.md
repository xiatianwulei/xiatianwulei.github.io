---
layout:     post
title:      Swift UI初始化方法的职责
subtitle:   
date:       2022-03-11
author:     夏天无泪
header-img: img/post-bg-digital-native.jpg?raw=true
catalog: true
tags:
    - Swift
---

# Swift UI 初始化方法的正确职责

在 iOS 开发中，正确理解和使用生命周期方法是非常重要的，尤其是当使用 NIB/XIB 文件或进行 UI 配置时。下面是关于常用生命周期方法的职责和最佳实践：

## 一、`awakeFromNib()` 的正确职责

`awakeFromNib()` 方法会在 NIB/XIB 文件加载并初始化所有视图后立即调用。此时，虽然视图已经实例化，但有以下几点需要注意：

- **视图尚未布局**：此时 `frame` 和 `bounds` 可能还不准确。
- **视图层级可能不完整**：子视图可能尚未完全加入父视图。
- **主 Actor 上下文可能未完全建立**：在 Swift 6 中，主线程的严格检查可能导致访问 UI 属性时出现问题。

**适合放在 `awakeFromNib()` 中的操作：**

1. **非 UI 的初始化**：如设置数据模型、注册通知。
2. **一次性配置**：如设置代理、添加 KVO 观察。
3. **弱引用存储**：如保存对 `ViewModel` 的引用。

**示例：**

```swift
override func awakeFromNib() {
    super.awakeFromNib()
    
    // 注册通知中心
    NotificationCenter.default.addObserver(
        self,
        selector: #selector(handleNotification),
        name: .someNotification,
        object: nil
    )
    
    // 设置代理
    someView.delegate = self
    
    // 非 UI 配置
    isUserInteractionEnabled = true
}
```

## 二、`layoutSubviews()` 的职责

`layoutSubviews()` 方法会在每次视图布局时调用（包括首次显示前）。此时的特点包括：

- **视图层级已完全建立**：所有子视图都已经加入父视图。
- **`frame` 和 `bounds` 已确定**：此时可以安全地访问视图的布局属性。
- **主 Actor 上下文已完全建立**：可以安全地进行 UI 更新。

**适合放在 `layoutSubviews()` 中的操作：**

1. **UI 初始化**：如设置初始状态、添加子视图。
2. **动态布局**：根据 `bounds` 调整子视图的位置或大小。
3. **响应式 UI 更新**：根据数据状态显示或隐藏元素。

**示例：**

```swift
override func layoutSubviews() {
    super.layoutSubviews()
    
    // 安全的 UI 初始化
    registerStatusImageView.isHidden = true
    
    // 动态布局（如根据 cell 宽度调整子视图）
    if bounds.width > 320 {
        someView.frame = CGRect(x: 10, y: 10, width: bounds.width - 20, height: 40)
    }
}
```

## 三、其他可替代的生命周期方法

### 1. `didMoveToSuperview()`

在视图被添加到父视图后调用，只会执行一次。适用于视图首次添加时的初始化操作。

**示例：**

```swift
override func didMoveToSuperview() {
    super.didMoveToSuperview()
    if superview != nil {
        // 仅在视图首次添加到父视图时执行
        registerStatusImageView.isHidden = true
    }
}
```
### 2. `willMove(toSuperview:)`
在视图即将被添加到父视图时调用。适用于需要预配置的场景。

**示例：**
```
override func willMove(toSuperview newSuperview: UIView?) {
    super.willMove(toSuperview: newSuperview)
    if newSuperview != nil {
        // 即将被添加到父视图时执行
        registerStatusImageView.isHidden = true
    }
}
```
## 四、Swift 6 下的最佳实践

在 Swift 6 中，`@MainActor` 和严格的并发检查要求我们更加小心地处理 UI 更新。

### 1. 避免在 `awakeFromNib()` 中直接操作 UI

在 `awakeFromNib()` 中，不要直接操作 UI 属性。可以使用 `DispatchQueue.main.async` 或 `Task { @MainActor in ... }` 来确保 UI 更新在主线程中执行。

### 2. 优先在 `layoutSubviews()` 中初始化 UI

`layoutSubviews()` 是在视图布局完成时调用的，此时可以安全地进行 UI 更新。避免在该方法中进行过多的初始化逻辑，以减少不必要的调用。

### 3. 使用 `@MainActor` 标记整个类

标记类为 `@MainActor`，可以确保所有方法都在主线程上执行，避免并发访问 UI 时的线程安全问题。

**示例：封装 UI 更新逻辑**

```swift
private func updateUI() {
    Task { @MainActor in
        registerStatusImageView.isHidden = true
        // 其他 UI 更新...
    }
}
```
## 五、总结

| 方法                        | 适合场景                      | Swift 6 注意事项                      |
|----------------------------|-------------------------------|----------------------------------------|
| `awakeFromNib()`            | 非 UI 初始化、设置代理        | 避免直接访问 UI 属性                   |
| `layoutSubviews()`          | UI 初始化、动态布局          | 安全访问 UI，但可能被多次调用         |
| `didMoveToSuperview()`      | 一次性 UI 初始化             | 视图添加到父视图后执行                 |
| `willMove(toSuperview:)`    | 视图即将添加到父视图时       | 可用于预配置 UI                       |


## 六、补充

### 修改约束 / 布局的逻辑 应该放在 `layoutSubviews()` 中（或普通方法中，由 `layoutSubviews()` 调用）

`layoutIfNeeded()` 仅仅是触发立即执行布局的 “开关”，本身不应该包含任何布局修改逻辑。

### 为什么不能在 `layoutIfNeeded()` 里修改约束？

1. **职责混淆**：`layoutIfNeeded()` 的设计目的是 “执行布局”，而不是 “定义布局规则”。它的作用是触发系统去计算和应用布局，而不是在里面编写 “如何布局” 的逻辑。
2. **可能导致循环**：如果在 `layoutIfNeeded()` 中修改约束，会再次标记布局为 “待更新”，可能引发重复调用，甚至死循环。
3. **不符合系统设计**：系统的布局流程是：`setNeedsLayout()`（标记需要更新）→ `layoutIfNeeded()`（触发执行）→ 自动调用 `layoutSubviews()`（执行具体布局）。修改约束的逻辑属于 “执行具体布局” 的部分，理应放在 `layoutSubviews()` 中。

### 正确的代码组织方式

假设你需要根据数据模型修改拖拽相关的约束，应该这样做：

```swift
// 1. 重写 layoutSubviews()，在这里编写布局逻辑
override func layoutSubviews() {
    super.layoutSubviews() // 必须先调用父类方法
    
    // 根据数据模型修改约束（这是正确的位置）
    updateConstraintsWithModel()
}

// 2. 单独的方法处理约束修改
private func updateConstraintsWithModel() {
    // 例如：根据 model 的拖拽位置更新约束
    dragConstraint.constant = model.dragOffset
    // 其他布局调整...
}

// 3. 需要立即更新布局时，调用 layoutIfNeeded() 触发
func someAction() {
    // 当数据模型变化后，需要立即看到布局效果
    model.dragOffset = 100
    layoutIfNeeded() // 仅触发，不包含布局逻辑
}
```

#### 写个小demo 记录下

##### cell
```
import UIKit

class DynamicHeightCell: UITableViewCell {
    // 从XIB拖线的Label
    @IBOutlet weak var contentLabel: UILabel!
    // 从XIB拖线的Label高度约束
    @IBOutlet weak var labelHeightConstraint: NSLayoutConstraint!
    // 切换按钮
    @IBOutlet weak var toggleButton: UIButton!
    
    // 记录展开状态
    var isExpanded: Bool = false {
        didSet {
            // 状态改变时更新UI
            updateLabelHeight()
        }
    }
    
    // 点击按钮的回调闭包
    var onToggle: (() -> Void)?
    
    override func awakeFromNib() {
        super.awakeFromNib()
        // 初始化设置
        updateLabelHeight()
    }
    
    // 在layoutSubviews中确保布局正确
    override func layoutSubviews() {
        super.layoutSubviews()
        // 可以在这里根据需要调整布局
        // 例如：根据当前状态确保约束正确应用
        updateLabelHeight()
    }
    
    // 更新Label高度约束
    private func updateLabelHeight() {
        // 根据状态设置不同的高度
        labelHeightConstraint.constant = isExpanded ? 100 : 20
        // 强制刷新当前Cell的布局
        layoutIfNeeded()
    }
    
    // 按钮点击事件
    @IBAction func toggleButtonTapped(_ sender: UIButton) {
        onToggle?()
    }
    
    // 配置Cell内容
    func configure(with text: String) {
        contentLabel.text = text
        // 根据内容多少可能需要设置换行模式
        contentLabel.numberOfLines = isExpanded ? 0 : 1
    }
} 

```
    
    
##### vc
    
```
import UIKit

class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {
    
    @IBOutlet weak var tableView: UITableView!
    
    // 存储每个cell的展开状态
    var expandedStates: [Bool] = Array(repeating: false, count: 10)
    // 测试数据
    let cellTexts: [String] = {
        var texts = [String]()
        for i in 0..<10 {
            texts.append("这是第\(i+1)个单元格的内容，点击按钮可以展开更多内容查看完整信息。")
        }
        return texts
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 注册XIB文件
        tableView.register(UINib(nibName: "DynamicHeightCell", bundle: nil), forCellReuseIdentifier: "DynamicHeightCell")
        
        // 设置自动计算高度
        tableView.rowHeight = UITableView.automaticDimension
        tableView.estimatedRowHeight = 60
    }
    
    // MARK: - UITableViewDataSource
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return cellTexts.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "DynamicHeightCell", for: indexPath) as! DynamicHeightCell
        
        // 配置Cell
        cell.configure(with: cellTexts[indexPath.row])
        cell.isExpanded = expandedStates[indexPath.row]
        cell.toggleButton.setTitle(cell.isExpanded ? "收起" : "展开", for: .normal)
        
        // 设置按钮点击回调
        cell.onToggle = { [weak self] in
            guard let self = self else { return }
            
            // 切换状态
            self.expandedStates[indexPath.row].toggle()
            
            // 更新按钮文字
            cell.toggleButton.setTitle(self.expandedStates[indexPath.row] ? "收起" : "展开", for: .normal)
            
            // 通知TableView更新高度
            tableView.beginUpdates()
            tableView.endUpdates()
        }
        
        return cell
    }
}
```