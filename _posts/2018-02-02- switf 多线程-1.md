---
layout:     post
title:      多线程 - Thread
subtitle:   
date:       2018-02-02
author:     夏天无泪
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Switf
    - 学习整理
---

#  switf 多线程 - Thread

### 一、 Thread
Tread在三种多线程技术中是最轻量级的，但需要自己管理线程的生命周期和线程同步。线程同步对数据的加锁会有一定的系统开销。

1. Thread的两种创建方式
（1）直接创建线程并且自动运行线程
（2）先创建一个线程对象，然后手动运行线程，在运行线程操作之前可以设置线程的优先级等线程信息。

```
import UIKit
 
class ViewController: UIViewController {
     
    override func viewDidLoad() {
        super.viewDidLoad()
         
        //方式1：使用类方法
        Thread.detachNewThreadSelector(#selector(ViewController.downloadImage),
                                       toTarget: self, with: nil)
         
        //方式2：实例方法-便利构造器
        let myThread = Thread(target: self,
                              selector: #selector(ViewController.downloadImage),
                              object: nil)
        myThread.start()
    }
     
    //定义一个下载图片的方法，线程调用
    func downloadImage(){
        let imageUrl = "http://hangge.com/blog/images/logo.png"
        let data = try! Data(contentsOf: URL(string: imageUrl)!)
        print(data.count)
    }
     
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
}
```

1. 线程同步

```
import UIKit
 
class ViewController: UIViewController {
     
    //定义两个线程
    var thread1:Thread?
    var thread2:Thread?
     
    //定义两个线程条件，用于锁住线程
    let condition1 = NSCondition()
    let condition2 = NSCondition()
     
    override func viewDidLoad() {
        super.viewDidLoad()
         
        thread2 = Thread(target: self, selector: #selector(ViewController.method2),
                         object: nil)
        thread1 = Thread(target: self, selector: #selector(ViewController.method1),
                         object: nil)
        thread1?.start()
    }
     
    //定义两方法，用于两个线程调用
    func method1(sender:AnyObject){
        for i in 0 ..< 10 {
            print("Thread 1 running \(i)")
            sleep(1)
             
            if i == 2 {
                thread2?.start() //启动线程2
                 
                //本线程（thread1）锁定
                condition1.lock()
                condition1.wait()
                condition1.unlock()
            }
        }
         
        print("Thread 1 over")
         
        //线程2激活
        condition2.signal()
    }
     
    //方法2
    func method2(sender:AnyObject){
        for i in 0 ..< 10 {
            print("Thread 2 running \(i)")
            sleep(1)
             
            if i == 2 {
                //线程1激活
                condition1.signal()
                 
                //本线程（thread2）锁定
                condition2.lock()
                condition2.wait()
                condition2.unlock()
            }
        }
         
        print("Thread 2 over")
    }
     
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
}

```

### 二、 Operation和OperationQueue
Cocoa Operation不需要关心线程管理和数据同步的事情，可以把精力放在自己需要执行的操作上。相关的类有Operation和OperationQueue。其中Operation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的子类：BlockOperation。创建Operation子类的对象，把对象添加到OperationQueue队列里执行。

1. 使用Operation的两种方式
 
（1）直接用定义好的子类：BlockOperation。

```
import UIKit
 
class ViewController: UIViewController {
     
    override func viewDidLoad() {
        super.viewDidLoad()
         
        let operation = BlockOperation(block: { [weak self] in
            self?.downloadImage()
            return
            })
         
        //创建一个NSOperationQueue实例并添加operation
        let queue = OperationQueue()
        queue.addOperation(operation)
    }
     
    //定义一个下载图片的方法，线程调用
    func downloadImage(){
        let imageUrl = "http://hangge.com/blog/images/logo.png"
        let data = try! Data(contentsOf: URL(string: imageUrl)!)
        print(data.count)
    }
     
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
}
```

（2）继承Operation 
然后把Operation子类的对象放入OperationQueue队列中，一旦这个对象被加入到队列，队列就开始处理这个对象，直到这个对象的所有操作完成，然后它被队列释放。
```
import UIKit
 
class ViewController: UIViewController {
     
    override func viewDidLoad() {
        super.viewDidLoad()
         
        //创建线程对象
        let downloadImageOperation = DownloadImageOperation()
         
        //创建一个OperationQueue实例并添加operation
        let queue = OperationQueue()
        queue.addOperation(downloadImageOperation)
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
}
 
class DownloadImageOperation: Operation {
    override func main(){
        let imageUrl = "http://hangge.com/blog/images/logo.png"
        let data = try! Data(contentsOf: URL(string: imageUrl)!)
        print(data.count)
    }
}

```


2. 设置运行队列并发数 
OperationQueue队列里可以加入很多个Operation，可以把OperationQueue看做一个线程池，可往线程池中添加操作（Operation）到队列中。
可以设置线程池中的线程数，也就是并发操作数。默认情况下是-1，-1表示没有限制，这样可以同时运行队列中的全部操作。

```
//设置并发数
queue.maxConcurrentOperationCount = 5
```

3. 取消队列所有操作

```
//取消所有线程操作
queue.cancelAllOperations()
```
1. 每个Operation完成都会有一个回调表示任务结束

```
//给operation设置回调
operation.completionBlock = { () -> Void in
    print("--- operation.completionBlock ---")
}
```