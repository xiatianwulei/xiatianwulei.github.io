---
layout:     post
title:      基于协议的组件化解耦：定位服务
subtitle:   
date:       2025-05-09
author:     夏天无泪
header-img: img/post-bg-ios9-web.jpg?raw=true
catalog: true
tags:
    - Swift
---

# 组件化解耦：基于协议的定位服务设计方案
背景
在组件化开发中，子工程与主工程的依赖关系需要严格控制，避免子工程直接依赖主工程的具体实现，导致耦合过高。本文记录一种基于协议的定位服务解耦方案，通过抽象协议隔离接口定义与实现，实现子工程与主工程的低耦合。

方案设计
核心思路：子工程定义协议，主工程实现协议，通过单例注入实现依赖反转。
1. 子工程：定义抽象协议
在子工程中声明定位服务的协议接口，规定必须实现的属性和方法，子工程仅依赖此协议，不关心具体实现。

```
// 子工程 - LocationServiceProtocol.swift
import Foundation
import RxCocoa

// 定位服务协议（核心抽象）
public protocol LocationServiceProtocol: AnyObject {
    /// 定位状态可观察对象（供外部订阅）
    var currentLocationStatusObservable: BehaviorRelay<LocationStatus> { get }
    /// 城市数据可观察对象（供外部订阅）
    var currentCityDataObservable: BehaviorRelay<LocationRaw?> { get }
    /// 开始定位方法
    func startLocating()
}

// 定位服务单例（用于注入实现）
public class LocationService {
    private static var _shared: LocationServiceProtocol?
    
    /// 全局共享实例（必须在主工程中设置实现）
    public static var shared: LocationServiceProtocol {
        get {
            guard let instance = _shared else {
                fatalError("LocationService.shared 尚未赋值，请在主工程中设置")
            }
            return instance
        }
        set {
            _shared = newValue
        }
    }
}
```

2. 主工程：实现协议
主工程依赖具体的定位 SDK（如腾讯 LBS、高德地图等），实现子工程定义的 LocationServiceProtocol 协议，并通过单例注入到子工程中。

```
// 主工程 - LocationServiceManager.swift
import Foundation
import TencentLBS
import RxCocoa
import CoreLocation

// 主工程实现定位服务协议
public class LocationServiceManager: NSObject, TencentLBSLocationManagerDelegate, LocationServiceProtocol {
    // 实现协议的可观察对象
    public var currentLocationStatusObservable = BehaviorRelay<LocationStatus>(value: .uninitialized)
    public var currentCityDataObservable = BehaviorRelay<LocationRaw?>(value: nil)
    
    // 腾讯定位管理器（具体 SDK 依赖）
    private let locationManager = TencentLBSLocationManager()
    
    override init() {
        super.init()
        // 配置定位参数
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyThreeKilometers
        locationManager.distanceFilter = 1000
    }
    
    // 实现协议方法：开始定位
    public func startLocating() {
        currentLocationStatusObservable.accept(.locating)
        locationManager.startUpdatingLocation()
    }
    
    // 腾讯 LBS 定位回调（成功）
    public func locationManager(_ manager: TencentLBSLocationManager!, didUpdate location: TencentLBSLocation!) {
        let locationRaw = LocationRaw(
            city: location.city,
            latitude: location.coordinate.latitude,
            longitude: location.coordinate.longitude
        )
        currentCityDataObservable.accept(locationRaw)
        currentLocationStatusObservable.accept(.success)
        locationManager.stopUpdatingLocation()
    }
    
    // 腾讯 LBS 定位回调（失败）
    public func locationManager(_ manager: TencentLBSLocationManager!, didFailWithError error: Error!) {
        currentLocationStatusObservable.accept(.failed(error.localizedDescription))
        locationManager.stopUpdatingLocation()
    }
}

// 主工程初始化时注入实现
extension LocationService {
    static func setup() {
        shared = LocationServiceManager()
    }
}

// 在主工程启动时调用
// AppDelegate 或 SceneDelegate 中：
// LocationService.setup()
```

## 方案优势 ##
彻底解耦
1. 子工程仅依赖 LocationServiceProtocol 协议，不直接引用主工程的 LocationServiceManager 或定位 SDK，实现了 “子工程 → 协议” 的单向依赖，避免循环依赖。
2. 灵活替换实现
若未来需要更换定位 SDK（如从腾讯 LBS 换成高德地图），只需新增一个实现 LocationServiceProtocol 的类（如 AMapLocationManager），通过 LocationService.shared = AMapLocationManager() 注入即可，子工程无需任何修改。
3. 便于测试
测试环境可使用模拟实现类（如 MockLocationService），通过注入模拟数据快速测试定位相关业务逻辑，无需依赖真实定位 SDK。
4. 接口清晰
协议明确规定了定位服务的核心能力（状态监听、城市数据、启动定位），所有调用方遵循统一接口，降低协作成本。

使用示例（子工程中调用）
子工程通过 LocationService.shared 访问定位服务，完全基于协议交互：

```
// 子工程中使用定位服务
func useLocationService() {
    // 订阅定位状态
    LocationService.shared.currentLocationStatusObservable
        .subscribe(onNext: { status in
            switch status {
            case .locating:
                print("正在定位...")
            case .success:
                print("定位成功")
            case .failed(let error):
                print("定位失败：\(error)")
            default: break
            }
        })
        .disposed(by: disposeBag)
    
    // 订阅城市数据
    LocationService.shared.currentCityDataObservable
        .subscribe(onNext: { cityData in
            if let city = cityData?.city {
                print("当前城市：\(city)")
            }
        })
        .disposed(by: disposeBag)
    
    // 开始定位
    LocationService.shared.startLocating()
}
```

总结
本方案通过 “协议定义接口 + 单例注入实现” 的方式，完美隔离了子工程与主工程的依赖关系，符合组件化开发的 “高内聚、低耦合” 原则。核心价值在于依赖抽象而非具体实现，让各组件可以独立演化，提高代码的可维护性和扩展性。