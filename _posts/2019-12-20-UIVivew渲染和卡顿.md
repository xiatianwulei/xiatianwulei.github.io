---
layout:     post
title:      UIVivew 渲染原理和卡顿分析原理 
subtitle:   
date:       2019-12-20
author:     夏天无泪
header-img: img/post-bg-android.jpg?raw=true
catalog: true
tags:
    - 学习整理
---

# UIVivew 的绘制原理 
  

## 图像显示原理  

![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media//UIVivew渲染和卡顿/ios_screen_display.png?raw=true)  

**概述**：CPU与GPU是通过总线连接起来，通过CPU输出一个位图，经由总线传输在合适的时机上传到GPU，GPU获取到位图后，会进行图层渲染、纹理合成，将结果放入帧缓存区中缓冲区，有两块缓冲区，前帧缓存和后帧缓存，协调使用，效率高），由视频控制器根据VSyn信号，在指定时间之前提取帧缓存区中的屏幕显示内容，最终显示到手机屏幕上。    
    
   **简单概括** 
 >CPU 计算数据 -> GPU 进行渲染 -> 渲染结果存入帧缓冲区 -> 视频控制器会按照 VSync 信号逐帧读取帧缓冲区的数据 -> 成像
 
## 总体概括  CPU与GPU分别做了什么?  

创建UIView后，显示部分由CALayer负责，CALayer有一个contents属性，就是我们最终要绘制到屏幕上的位图，如果我们创建的是UILabel，那么contents上最终要绘制就是“Hello”的位图,系统在合适的时候回调给我们一个drawRect的方法，然后我们可以在此基础上绘制一些我们想自定义绘制的内容，绘制好的这个位图，会经过Core Animation提交给GPU部分的OpenGL渲染管线，进行最终的位图的渲染以及文理的合成，最终显示到屏幕上。

![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media//UIVivew渲染和卡顿/display_sepereate.png?raw=true)


**CPU要做的工作**  

1. Layout: 这里主要涉及到一些UI布局，文本计算等，例如一个label的size  
2. Display: 绘制阶段（drawRect），例如drawRect方法就在这一步骤中
3. Prepare: 图片的编解码等操作在此步骤中
4. Commit: 提交位图  

**GPU 渲染管线**  

* 顶点着色
* 图元装配
* 光栅化
* 片段着色
* 片段处理


### 一、 UIView的绘制原理  

当调用UIView的`setNeedsDisplay`方法时，其实并没有立即进行绘制工作，会调用`CALayer`的同名方法`setNeedsDisplay`,这时并没有立即发生绘制，而只是相当于在当前`layer`打上了标记,会在`Runloop`即将结束时才会调`[CALayer display]`然后进入我们视图的真正绘制过程。  

而在`[CALayer display]`这个方法的内部实现中会判断这个layer的delegate是否响应`displayLayer:`这个方法，如果不响应这个方法，就会进入到**系统绘制**流程中；如果响应这个方法，那么就会为我们提供**异步绘制**的入口 

![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media//UIVivew渲染和卡顿/display_flow.png?raw=true)  

#### 1. 系统绘制实现  

1) 在CALayer内部会先创建backing store，我可以理解为CGContext，我们一般在drawRect:方法中通过上下文堆栈当中取出栈顶的context,也就是上下文.  

2). 然后这个layer会判断是否有代理，如果没有代理，那么就会调用`[CALayer drawInContext:]`；如果有代理，会调用代理的`drawLayer:inContext:`方法，然后做当前视图的绘制工作（这一步是发生在系统内部的），然后在一个合适的时机给与我们这个十分熟悉的`[UIView drawRect:]`方法的回调，`[UIView drawRect:]`这个方法默认是什么都不做，，系统给我们开这个口子是为了让我们可以再做一些其他的绘制工作

3).  然后无论是哪个分支，最终都会由CALayer上传对应的backing store(可以理解为位图)给GPU，然后就结束了系统默认的绘制流程


![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media//UIVivew渲染和卡顿/system_display_new.png?raw=true)  

#### 2. 异步绘制实现  

我们需要通过实现layer的代理方法`displayLayer`    

* 在这个异步绘制过程中,代理负责生成对应的bitmap(位图)
* 同时设置bitmap作为layer.contents属性的值    

![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media//UIVivew渲染和卡顿/asyn_display.png?raw=true)  

* 假如说我们在某一个时机调用了`[view setNeedsDisplay]`这个方法，系统会在当前runloop将要结束的时候调用`[CALyer display]`方法，然后如果我们这个layer的代理实现了[view displayLayer]这个方法  
* 然后会通过子线程的切换，我们在子线程中去做一个位图的绘制，主线程可以去做一些其他的操作
* 在子线程中第一步先通过`CGBitmapContextCreate()`方法来创建一个位图的上下文，然后我们通过CoreGraphic API可以做当前UI控件的一些绘制工作，最后我们再通过`CGBitmapContextCreateImage()`这个函数来根据当前所绘制的上下文来生成一张CGImage图片
* 最后回到主线程来提交这个位图，设置layer的contents属性，这样就完成了一个UI控件的异步绘制过程

#### 3. 离屏渲染（便于理解视图卡顿、掉帧中对GPU的开销）  

**离屏渲染指的是:GPU在当前屏幕缓冲区以外开辟了一个缓冲区进行渲染操作**    

当前屏幕渲染不需要额外创建新的缓存，也不需要开启新的上下文，相对于离屏渲染性能更好。但是受当前屏幕渲染的局限因素限制(只有自身上下文、屏幕缓存有限等)，当前屏幕渲染有些情况下的渲染解决不了的，就使用到离屏渲染

On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行渲染操作  

Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作  

**当设置某些UI视图的图层属性，如果标记为未合成之前不能用于显示，那么就会触发离屏渲染**

触发离屏渲染的条件

* 圆角（和maskToBounds一起使用时）
* 图层蒙版(masks)
* 阴影(shadows)
* 光栅化 (shouldRasterize)
* 渐变
* 不透明(group opacity)

离屏渲染对性能的的代价是很高的，主要体现在：  

* 创建了新的缓冲区
* 上下文的频繁切换

**触发离屏渲染，增加GPU工作量，而GPU的工作的增加可能导致CPU+GPU产生一帧画面的时间超过16.7ms，就会产生卡顿掉帧，所以要避免离屏渲染。**  

#### 4.View绘制渲染机制和Runloop的关系  

当操作了UI，如改变frame、更新UIView或CALayer的层次、手动调用`setNeedsLayout`/`setNeedsDisplay`方法后，这个UIView/CAlayer就被标记成待处理，并被提交到一个全局的容器中。

在Runloop中，系统注册了一个observer来监听BeforeWaiting（即将休眠）和Exit（即将退出Runloop）事件，回调去执行一个函数，这个函数会遍历所有待处理的UIView/CALayer以执行实际的绘制和调整，并更新界面。  
·
具体为：observer检查函数 ->检查图层树中有没有待处理的对象 ->如果没有则runloop休眠 ->有则CPU更新图层树，交给Core Animation运走 ->Core Animation把待处理的图层对象，通过IPC发送给渲染进程 ->GPU开始渲染》发送到缓冲区 ->展示view



![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media//UIVivew渲染和卡顿/677071-0bb9dd062eb39699.png?raw=true)    

从上图中可以看到  

runloop的observer回调 => CoreAnimation渲染引擎一次事务的提交=>CoreAnimation递归查询图层是否有布局上的更新=>`CALayer layoutSublayers`=>`UIView layoutSubviews` 这样一个调用的流程。从这里也可以看到UIView其实就是相当于CALayer的代理。


**刷新视图补充:**  
`layoutSubviews`只有当子视图的自动调整、约束的行为不能满足你时，你才应该重写此方法.    

`setNeedsLayout`这个方法**标记**为需要重新布局，异步调用`layoutIfNeeded`刷新布局，不立即刷新，但`layoutSubviews`一定会被调用。  

`layoutIfNeeded`方法：如果有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`）  

> 在视图第一次显示之前，标记肯定是“需要刷新”的，所以直接调用`view.layoutIfNeeded()`就会进行立即更新。  
> 如果要在当前runloop立即刷新，要先调用`view.setNeedsLayout()`，把标记设为需要布局，然后马上调用`view.layoutIfNeeded`，实现布局。  

**只要知道什么时候调用`layoutIfNeeded`[stackoverflow解答](https://stackoverflow.com/questions/1182945/how-is-layoutifneeded-used)**，其余情况调用`setNeedsLayout `来优化性能。  
同时[`UIview需要知道的一些事情：setNeedsDisplay、setNeedsLayout`](https://www.jianshu.com/p/64ecfbc01536)。


### 二、图像显示原理 和 卡顿产生的原因 

![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media//UIVivew渲染和卡顿/ios_frame_drop.png?raw=true)  

**一帧（或一页）数据就是**：  
一个垂直同步信号（VSync ）和一个水平同步信号（HSync）的组合。先发送一个垂直同步信号（VSync ），代表即将显示一页，再发送一个水平同步信号（HSync）就显示一帧。如果当下一次VSync信号到来之前，CPU和GPU还没有计算完成，就会产生卡顿。

**卡顿产生的原因**：  
在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。**这就是界面卡顿的原因。**  
**结论：**  
从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化





