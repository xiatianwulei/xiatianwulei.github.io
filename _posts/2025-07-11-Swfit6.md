---
layout:     post
title:      Swift 6 调研
subtitle:   
date:       2025-07-11
author:     夏天无泪
header-img: img/post-bg-digital-native.jpg?raw=true
catalog: true
tags:
    - Swift
---


# Swift 6 调研

Swift 6 对于从 5.5 迁移的项目而言，最核心的挑战在于**线程安全模型的重构**，但除此之外，语言语法、标准库、工具链等方面的变化同样需要重点关注。本文将系统梳理迁移过程中的关键变更点、适配策略及实战经验，帮助团队平稳完成版本过渡。

## 一、核心变更：线程安全模型的升级

Swift 6 系列版本最显著的变化是引入了**强制线程安全检查**，彻底改变了 UI 操作与数据访问的编码范式。核心作用是明确指定该属性的线程归属，确保**它只能在主线程（主 actor）上被读写，从而避免多线程并发访问导致的数据竞争问题。**

### 1. @MainActor：UI 线程安全的强制约束

*   **特性本质**：`@MainActor` 是一个全局 Actor，用于标记必须在主线程执行的代码。被其修饰的类型、方法或属性，会被编译器强制检查调用线程。

*   **迁移影响**：

    *   所有 UI 组件（如 `UIView`、`UIViewController` 子类）默认隐式遵循 `@MainActor`，其方法调用必须在主线程完成。

    *   从后台线程调用 UI 方法（如 `view.layoutIfNeeded()`）会直接触发编译错误，而非运行时警告。

*   **适配策略**：

    *   使用 `MainActor.run` 包裹后台线程的 UI 操作：

```
// 错误示例（Swift 6 编译不通过）
// 全局并发队列（后台线程）执行
DispatchQueue.global().async {

    self.label.text = "更新文本" // 非主线程操作 UI

}

// 正确示例 但当需要更新 UI 时，使用 MainActor.run（或 DispatchQueue.main.async）将 UI 操作切换到主线程执行
DispatchQueue.global().async {
   let data = fetchData()
   MainActor.run {

   self.label.text = data // 强制切换至主线程

   }
}
```

*   对跨线程共享的属性，使用 `@MainActor` 修饰以明确线程归属：

```
@MainActor var userInfo: UserInfo? // 只能在主线程读写
```

#### 为什么需要这样做？
在多线程编程中，“跨线程共享属性” 是常见的风险点。
例如：
* 后台线程（如下载线程）修改 userInfo 的值
* 主线程同时读取 userInfo 并更新 UI

如果没有线程限制，可能导致 “读取到不完整 / 不一致的数据”。而 @MainActor 通过编译期检查强制约束：所有对 userInfo 的操作必须在主线程进行，从根本上避免了这种数据竞争。

### 2. Sendable：跨线程数据安全的契约

*   **特性本质**：`Sendable` 协议用于标记**可安全跨线程传递**的数据类型，确保并发访问时不会产生数据竞争。

### 1. 默认符合 Sendable 的类型
许多基础类型天生满足 Sendable 条件（不可变或线程安全），无需手动声明：
值类型：Int、String、Array、Dictionary 等（它们是 “值传递”，跨线程时会复制，不会共享内存）
不可变引用类型：被 @frozen 标记的枚举、Actor 类型（Actor 本身通过内部锁保证线程安全）
无状态类型：如空协议、仅包含 Sendable 成员的结构体
示例：

```
let age: Int = 20 // Int 符合 Sendable，可跨线程传递
let name: String = "Swift" // String 符合 Sendable

```

### 2. 需要手动声明 Sendable 的类型
自定义类型（如结构体、类、枚举）若要跨线程传递，需显式遵守 Sendable 协议，并确保其内部成员都符合 Sendable：
结构体 / 枚举：只需声明 Sendable（编译器会自动检查成员是否符合）

Sendable 的核心要求
1. Sendable 要求类型在跨线程传递时能保证线程安全。对于类（引用类型）来说，如果允许继承，子类可能会：
添加非 Sendable 的成员（破坏线程安全）
重写方法并引入不安全的并发逻辑
编译器无法提前预知子类的实现，因此默认不允许非 final 的类声明 Sendable（除非用 @unchecked Sendable 手动承担风险）。
2. final 的作用
final 通过禁止继承，确保类的实现是 “封闭” 的 —— 编译器可以完整检查类的所有成员和方法，确认其符合 Sendable 规则，从而保证线程安全。


```
swift
// 正确：所有成员都是 Sendable 类型
struct User: Sendable {
    let id: Int // Int 是 Sendable
    let name: String // String 是 Sendable
}
```

* 类：除了声明 Sendable，还需满足以下条件之一：
    * 类是 final（防止子类破坏线程安全）
    * 类是 Actor（本身具备线程安全机制）
    * 类是不可变的（所有属性都是 let 且符合 Sendable）
    
```
swift
// 正确：final 类 + 所有成员是 Sendable
final class Config: Sendable {
    let apiUrl: String
    init(apiUrl: String) {
        self.apiUrl = apiUrl
    }
}
```

### @unchecked Sendable 的作用
由于类中包含 var 可变属性，直接声明 Sendable 会报错。@unchecked Sendable 会跳过编译器的严格检查，但我们通过编码规范保证安全（只在主线程修改）。

### 使用规范（关键！）：
为了保证安全，需要团队遵守：
所有对 var 属性的修改必须在主线程（可以用 DispatchQueue.main.async 或 @MainActor 方法）
跨线程传递模型时，只做读取操作，不做修改

```
// 其他自定义类成员也采用同样方案
final class SubItem: @unchecked Sendable, Codable {
    var subName: String? // 允许修改（主线程）
    let subValue: Int? // 不可变属性
    
    // Codable自动生成或手动实现
}
```
*   **迁移影响**：

    *   闭包默认需要满足 `Sendable` 约束，捕获的变量必须是 `Sendable` 类型。

    *   自定义类型需显式声明 `Sendable` 合规性（值类型自动合规，引用类型需满足 `final` 或使用 `@Sendable`）。

*   **适配策略**：


    *   为自定义模型添加 `Sendable` 协议：



```
// 值类型自动合规

struct User: Sendable {

   let id: Int

   let name: String

}

// 引用类型需显式声明

final class Config: Sendable {

   private let settings: \[String: String]

   init(settings: \[String: String]) {
   
       self.settings = settings;
       
      }

}
```



*   对无法满足 `Sendable` 的类型，使用 `@preconcurrency` 临时兼容（需谨慎）：



```
@preconcurrency import ThirdPartySDK // 第三方库未适配 Sendable 时
```

## 二、语言语法与标准库的重要变更

除线程安全外，Swift 6.2 还对语言语法和标准库进行了多项优化，部分特性需要调整现有代码。

### 1. 可选值展开的严格性提升



*   **变更点**：强制要求可选值展开前必须确认非空，禁止隐式强制解包（`!`）的危险用法。

*   **迁移示例**：



```
// Swift 5.5 允许（风险高）

let text = user.name!

// Swift 6.2 推荐写法

guard let text = user.name else {

   logger.warning("用户名为空")

   return

}
```

### 2. 并发语法的稳定性增强



*   `async/await`** 升级**：Swift 6 完善了异步函数的错误处理与取消机制，支持 `withTaskCancellationHandler` 优雅处理任务取消。



```
func loadData() async throws {

   try await withTaskCancellationHandler(handler: {

        cancelRequest() // 任务取消时执行清理

   }) operation: {

      try await apiClient.fetchData()

   }

}
```



*   `TaskGroup`** 改进**：支持动态添加任务并更安全地管理子任务生命周期，避免内存泄漏。

### 3. 标准库新增与废弃 API



*   **新增特性**：


    *   `Collection` 协议新增 `contains(where:)` 的简化版本 `contains(if:)`。

    *   `String` 增加 `isNotEmpty` 属性，替代 `!isEmpty` 的繁琐写法。

*   **废弃 API**：


    *   `DispatchQueue.sync(execute:)` 被标记为废弃，推荐使用 `withCheckedThrowingContinuation` 转换为异步函数。

    *   `NSObject` 的 `value(forKey:)` 因类型不安全，在 Swift 6 中需显式声明 `@objc` 才能使用。

## 三、工具链与生态适配

版本迁移不仅涉及代码修改，还需要同步升级开发工具与依赖库。

### 1. Xcode 版本要求



*   Swift 6.2 需配套 **Xcode 15.0+**，旧版本 Xcode 无法编译 Swift 6 语法。

*   建议开启 **“Strict Concurrency Checking”**（在 Build Settings 中设置为 `Complete`），提前暴露线程安全问题。

### 2. 第三方库适配



*   **问题**：多数基于 Swift 5.5 的库未适配 `Sendable` 和 `@MainActor`，直接引用会导致编译错误。

*   **解决方案**：


    *   优先升级至支持 Swift 6 的库版本（如 Alamofire 5.8+、RxSwift 6.6+）。

    *   对暂不支持的库，使用 `@preconcurrency import` 临时兼容，但需在后续版本逐步替换。

### 3. 单元测试的调整



*   异步测试需使用 `async` 测试函数：



```
func testDataFetch() async throws {

   let result = try await dataService.fetch()

  XCTAssertEqual(result.count, 10)

}
```



*   需为测试类添加 `@MainActor` 以测试 UI 相关逻辑：



```
@MainActor

class ProfileViewControllerTests: XCTestCase {

   func testUpdateUI() {

      let vc = ProfileViewController()

       vc.loadViewIfNeeded()

      XCTAssertEqual(vc.nameLabel.text, "默认名称")

   }

}
```

## 四、迁移实战：分阶段实施策略

为降低迁移风险，建议采用**渐进式迁移**策略，分三阶段完成：

### 阶段 1：兼容模式运行



*   在 Build Settings 中设置 `Swift Language Version` 为 6.2，同时开启 `Strict Concurrency Checking = Minimal`。

*   利用 `@preconcurrency` 和 `@unchecked Sendable` 暂时绕过严格检查，确保项目能编译运行。

*   目标：快速让项目在 Swift 6.2 环境下跑通，记录编译错误与警告。

### 阶段 2：解决线程安全问题



*   逐步替换 `DispatchQueue` 为 `async/await`，消除跨线程 UI 操作。

*   为自定义类型添加 `Sendable` 合规性，清理非安全的闭包捕获。

*   目标：将 `Strict Concurrency Checking` 提升至 `Targeted`，解决大部分线程安全问题。

### 阶段 3：优化与原生适配



*   移除所有临时兼容代码（如 `@preconcurrency`），全面拥抱 `@MainActor` 和 `Sendable`。

*   利用 Swift 6 新特性重构代码（如 `TaskGroup` 替代传统并发模式）。

*   目标：达到 `Strict Concurrency Checking = Complete` 级别，充分享受 Swift 6 的安全与性能红利。

## 五、总结与展望

Swift 6.2 的迁移核心是**从 “开发者手动保证线程安全” 转向 “编译器强制约束”**，这虽然在短期内增加了迁移成本，但长期来看能显著减少并发 Bug，提升代码可维护性。

迁移过程中需注意：



*   优先解决线程安全相关的编译错误，这是 Swift 6 最核心的变更。

*   对第三方库保持耐心，采用临时兼容方案过渡。

*   利用 Xcode 的迁移工具（Edit > Convert > To Current Swift Syntax）自动处理部分语法变更。


