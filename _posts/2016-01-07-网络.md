---
layout:     post
title:      网络基础 
subtitle:   
date:       2016-01-07
author:     夏天无泪
header-img: img/post-bg-ios9-web.jpg?raw=true
catalog: true
tags:
    - 学习整理
---

# 网络基础 学习整理
### 一、网络协议的划分
概括：

![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media/15675017343464/15675647478734.jpg?raw=true)
![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media/15675017343464/15675902117228.jpg?raw=true)
#### 1.OSI七层网络模型
* 物理层：
    * 物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输；  
    * eg：RJ45等将数据转化成0和1；
       
* 数据链路层:
    * 数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控
    * 可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；  
* 传输层
    * 传输层向高层􏰁提供可靠的端到端的网络数据流服务。
    * 可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；
* 会话层
    * 会话层建立、管理和终止表示层与实体之间的通信会话；
    * 建立一个连接（自动的手机信息、自动的网络寻址）;
* 表示层:
    * 表示层􏰁供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;
    * 可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；
* 应用层:
    * OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;
    * 规定数据的传输协议；

常见的应用层协议：
![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media/15675017343464/15675657196965.jpg?raw=true)

#### 2.TCP/IP 协议基本概念
OSI 模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去。TCP/IP 没有照搬 OSI 模型,也没有 一个公认的 TCP/IP 层级模型,一般划分为三层到五层模型来􏰂述 TCP/IP 协议。

* 在此描述用一个通用的四层模型来描述,每一层都和 OSI 模型有较强的相关性但是又可能会有交叉。
* TCP/IP 的设计,是吸取了分层模型的精华思想——封装。每层对上一层􏰁供服务的时 候,上一层的数据结构是黑盒,直接作为本层的数据,而不需要关心上一层协议的任何细节。

#### 3. 四层模型 tcp/ip协议
1. 网络接口层
   * 网络接口层包括用于协作IP数据在已有网络介质上传输的协议。
它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议,􏰁供 TCP/IP 协议的数据结构和实际物理硬件之间的接口。
_可以理解为：确定了网络数据包的形式。_
1. 网间层
    *网间层对应于 OSI 七层参考模型的网络层，本层包含 IP 协议、RIP 协议(Routing Information Protocol,路由信息协议),负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来􏰁供网络诊断信息； _可以理解为：该层时确定计算机的位置。_
2. 传输层
    * 传输层对应于 OSI 七层参考模型的传输层,它􏰁供两种端到端的通信服务。其中 TCP 协议(Transmission Control Protocol)􏰁供可靠的数据流运输服务,UDP 协议(Use Datagram Protocol)􏰁供不可靠的用户数据报服务。
    _TCP:三次握手、四次挥手;UDP:只发不管别人收不收得到--任性哈_
    
3. 应用层
    * 应用层对应于 OSI 七层参考模型的应用层和表达层；不明白的再看看7层参考模型的描述。

TCP/IP 协议族常用协议
* 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等
* 传输层：TCP，UDP
* 网络层：IP，ICMP，OSPF，EIGRP，IGMP
* 数据链路层：SLIP，CSLIP，PPP，MTU  
 
#### 4.Http 和 Https 的区别？Https为什么更加安全？
* 区别
    1. HTTPS 需要向机构申请 CA 证书，极少免费。
    2. HTTP 属于明文传输，HTTPS基于 SSL 进行加密传输。
    3. HTTP 端口号为 80，HTTPS 端口号为 443 。
    4. HTTPS 是加密传输，有身份验证的环节，更加安全。
* 安全
    SSL(安全套接层) TLS(传输层安全)  
    
#### 5.HTTPS的连接建立流程 
_HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。在传输的过程中会涉及到三个密钥：_
* 服务器端的公钥和私钥，用来进行非对称加密
* 客户端生成的随机密钥，用来进行对称加密

流程图
![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media/15675017343464/15675674711067.jpg?raw=true)

步骤： 
  1. 客户端访问HTTPS连接。
    ` 客户端会把安全协议版本号、客户端支持的加密算法列表、随机数C发给服务端。  `   
    
2.服务端发送证书给客户端
` 服务端接收密钥算法配件后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接。否则，服务端会在该算法列表中，选择一种对称算法（如AES）、一种公钥算法（如具有特定秘钥长度的RSA）和一种MAC算法发给客户端。
`

`服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
`
`在发送加密算法的同时还会把数字证书和随机数S发送给客户端
`
3.客户端验证server证书
`会对server公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。
`
4.客户端组装会话秘钥
`如果公钥合格，那么客户端会用服务器公钥来生成一个预主秘钥(Pre-Master Secret，PMS)，并通过该语主秘钥和随机数C、S来组装成会话秘钥
`
5.客户端将语主秘钥加密发送给服务端
`是通过服务端的公钥来对前主秘钥进行非对称加密，发送给服务端
`
6.服务端通过私钥解密得到预主秘钥
`服务端接收到加密信息后，用私钥解密得到预主秘钥。
`
7.服务端组装会话秘钥
`服务端通过前主秘钥和随机数C、S来组装会话秘钥。

至此，服务端和客户端都已经知道了用于此次会话的主秘钥。
`
8.数据传输
`客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。
`
同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。


#### 6. 三次握手 和 四次挥手
![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media/15675017343464/15675874589634.jpg?raw=true)
注：seq:"sequance"序列号；ack:"acknowledge"确认号；SYN:"synchronize"请求同步标志；；ACK:"acknowledge"确认标志"；FIN："Finally"结束标志。
*三次握手*
`   1. 由客户端向服务端发送 SYN 同步报文。
    2. 当服务端收到 SYN 同步报文之后，会返回给客户端 SYN 同步报文和 ACK 确认报文。
    3. 客户端会向服务端发送 ACK 确认报文，此时客户端和服务端的连接正式建立。
`
*建立连接*
`1.这个时候客户端就可以通过 Http 请求报文，向服务端发送请求
 2.服务端接收到客户端的请求之后，向客户端回复 Http 响应报文。
`
*四次挥手*
`当客户端和服务端的连接想要断开的时候，要经历四次挥手的过程，步骤如下：
    1.先由客户端向服务端发送 FIN 结束报文。
    2.服务端会返回给客户端 ACK 确认报文 。此时，由客户端发起的断开连接已经完成。
    3.服务端会发送给客户端 FIN 结束报文 和 ACK 确认报文。
    4.客户端会返回 ACK 确认报文到服务端，至此，由服务端方向的断开连接已经完成。
`

#### 7. DNS
*因特网上的主机，可以使用多种方式标识，比如主机名或IP地址。一种标识方法就是用它的主机名（hostname），比如·www.baidu.com、www.google.com、gaia.cs.umass.edu等。这方式方便人们记忆和接受，但是这种长度不一、没有规律的字符串路由器并不方便处理。还有一种方式，就是直接使用定长的、有着清晰层次结构的IP地址，路由器比较热衷于这种方式。为了折衷这两种方式，我们需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统（Domain Name System，DNS）的主要任务。*
_可以简单地理解为将URL转换为IP地址_
* NDS是：  
    `1. 一个由分层的DNS服务器实现的分布式数据库
     2.一个使得主机能够查询分布式数据库的应用层协议
    `
* DNS服务器通常是运行BIND软件的UNIX机器，DNS协议运行在UDP上，使用53号端口
* DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP等。其作用则是：将用户提供的主机名解析为IP地址
* DNS的一种简单设计就是在因特网上只使用一个DNS服务器，该服务器包含所有的映射。很明显这种设计是有很大的问题的：
    * 单点故障：如果该DNS服务器崩溃，全世界的网络随之瘫痪
    * 通信容量：单个DNS服务器必须处理所有DNS查询
    * 远距离的集中式数据库：单个DNS服务器必须面对所有用户，距离过远会有严重的时延。
    * 维护：该数据库过于庞大，还需要对新添加的主机频繁更新。   
    
*所以，DNS被设计成了一个分布式、层次数据库*

#### 9.DNS解析过程
以www.163.com为例:
1. 客户端打开浏览器，输入一个域名。比如输入www.163.com，这时，客户端会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
2. 查询www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
3. 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。
4. 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
5. 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

#### 10.Cookie和Sessionm
cookie
主要是用来记录用户状态，区分用户，状态保存在客户端。cookie功能需要浏览器的支持。如果浏览器不支持cookie（如大部分手机中的浏览器）或者把cookie禁用了，cookie功能就会失效。
Sessionm
Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。
Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。

![](https://github.com/xiatianwulei/xiatianwulei.github.io/blob/master/img/media/15675017343464/15675860085292.jpg?raw=true)
如图：
当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为SessionId）

如果已包含则说明以前已经为此客户端创建过session，服务器就按照SessionId把这个session检索出来，使用（检索不到，会新建一个）

如果客户端请求不包含SessionId，则为此客户端创建一个session并且生成一个与此session相关联的SessionId，SessionId的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个SessionId将被在本次响应中返回给客户端保存。

保存这个SessionId的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把SessionId传递回服务器。

Cookie 和Session 的区别：
1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie相比session不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。而session存储在服务端，可以无限量存储
5. 所以：将登录信息等重要信息存放为session;其他信息如果需要保留，可以放在cookie中

#### 11.网络请求过程
*在浏览器中输入 http://www.baidu.com/ 后执行的全部过程。*
现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com， 而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：

1. 客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层

2. 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。

3. 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器

4. 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。




